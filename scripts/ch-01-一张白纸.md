### ***Shader贴图*** 
用shader画贴图和静态的贴图比，优点是能够提供更丰富的视觉变化；主要缺点之一是shader贴图没有图片贴图那样现成的filter可以作为抗锯齿手段，因此需要自行解决锯齿问题。

用Shader画各种纹案的贴图也叫Procedual Texture，随机、仿生、分型这些捣鼓出来的Generative Art，让人欲罢不能。

通常WebGL是在三维空间里面绘制，简单起见，先在二维平面进行绘制，避免一开始就纠缠三维空间变换的细节。

先绘制两个三角形，再配上纹理坐标，就是一张完美的shader画布了！

示例代码如下：

* 包含4个点的顶点数据和纹理坐标数据
```
  var verticesTexCoords = new Float32Array([
    // vertex coordinates, texture coordinate
    -1.0,  1.0,   0.0, 1.0,
    -1.0, -1.0,   0.0, 0.0,
     1.0,  1.0,   1.0, 1.0,
     1.0, -1.0,   1.0, 0.0,
  ]);
```
* 顶点着色器
```
  'attribute vec4 a_Position;\n' +
  'attribute vec2 a_TexCoord;\n' +
  'varying vec2 v_TexCoord;\n' +
  'void main() {\n' +
  '  gl_Position = a_Position;\n' +
  '  v_TexCoord = a_TexCoord;\n' +
  '}\n';
```

* 片元着色器
```
  '#ifdef GL_ES\n' +
  'precision mediump float;\n' +
  '#endif\n' +
  'uniform sampler2D u_Sampler;\n' +
  'varying vec2 v_TexCoord;\n' +
  'void main() {\n' +
  '  gl_FragColor = vec4(v_TexCoord.x, v_TexCoord.y, abs(v_TexCoord.x - v_TexCoord.y), 1.0);\n' +
  '}\n';
```
这个简单的画布，在片元着色器中，像素的RGB颜色根据uv坐标确定，R通道映射为uv的横向x坐标，G通道映射为UV的纵向坐标，B通道用UV的纵横坐标进行了一次运算后映射，生成效果如下：

![canvas-preview](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/7.jpg "uv")

源代码在这里： [the-codex-of-shader-graffiti/ch-01/quad.js](https://github.com/guoweish/the-codex-of-shader-graffiti/blob/master/ch-01/quad.js)
      

绘制好的shader贴图，可以和图片一样作为纹理贴到几何体上面；通常可以用一个FBO生成贴图，后续详细展开。

![procedual-texture](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/2.jpg "uv")

### ***UV坐标*** 
Shader画图，最重要的参考系就是纹理坐标。和常见的坐标系略有不同的是，纹理坐标通常把（0，0）放在左下角，（1，1）放在右上角。


![uv-canvas](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/1.jpg "uv")


纹理坐标的初始值在顶点着色器中以attribute变量传入，通过在顶点着色器和片元着色器中声明同名的varying变量，对纹理坐标的初始值进行光栅化插值。

```
  '...;\n'
  'attribute vec2 a_TexCoord;\n' +
  'varying vec2 v_TexCoord;\n' +
  '  ...' +
  '  v_TexCoord = a_TexCoord;\n' +
  '...';
```

### ***偏移UV中心点*** 
![transfer-center](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/3.jpg "uv")


### ***面向像素编程*** 
![pixel-distance](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/5.jpg "uv")

在一个平面上用shader绘制二维纹理，其实是一个面向像素编程的过程。

比如要画一个圆形，则需要告诉GPU，哪些像素是符合这个圆的定义规则的。如上图所示，给定一个圆心P，则P1在圆内部，P2在圆边缘，P3在圆外。由此可见单个像素到圆心的距离是判定该像素是否构成该圆图形的可行规则。

示例shader如下：
```
  '...;\n'
  '  float distPix = distance(v_TexCoord, vec2(0.5, 0.5));\n' +
  '  float isCircle = 1.0 - step(0.3, distPix);\n' +
  '  gl_FragColor = vec4(vec3(isCircle), 1.0);\n' +
  '...';
```
distance可以计算单个像素到给定圆心的距离，通过step函数，判定该像素在圆内外的着色规则，圆内为白，圆外为黑。

### ***矫正UV长宽比*** 
![uv-scale](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/4.jpg "uv")

### ***时间作为驱动变量***
![time-params](https://raw.githubusercontent.com/guoweish/the-codex-of-shader-graffiti/master/scripts/images/ch-01/6.jpg "uv")

